#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char board[16][16];


void voidBoard(char* b, int row, int col){
    for(int i = 0; i < row; i++){
        for(int j = 0; j < col; j++){
            b[i*col + j] = ' ';
        }
    }
}

void Labirint(char* b, int row, int col){
    for(int i = 0; i < row; i++){
        for(int j = 0; j < col; j++){
            if((i == 0) || (j == 0 && i >=3) || (i == 15) || (j == 15 && i <= 13)||(i >= 1 && i <= 6 && j == 5) || (i>=9 && i<= 15 && j == 10))
                b[i*col + j] = '#';
            else if((i >= 10 && i <= 12 && j == 9) || (i == 4 && j>=11 && j<=13))
                b[i*col + j] = '$';
            else if(i == 14 && j == 7)
                b[i*col + j] = '!';
            else if((i >= 1 && i <= 2 && j == 0) || (i >= 12 && i >=14 && j == 15))
                b[i*col + j] = ' ';
        }
    }
}

void printLabirint(char* b, int row, int col){
    for(int i = 0; i < row; i++){
        for(int j = 0; j < col; j++){
            printf("%c", b[i*col+j]);
        }
        printf("\n");
    }
}


void start(char* b, int row, int col){

    char snake = '.';

    for(int i = 0; i < row; i++){
        for(int j = 0; j < col; j++){
            if(j == 0 && b[i*col + j] == ' ' && b[(i+1)*col + j] != ' ')
                b[i*col + j] = snake;
        }
    }
}

void Moving(char* b, int row, int col){

    char move;
    int flag = 0;
    int currentPosition = 128;
    do{
        scanf(" %c", &move);
        switch(move){
            case 'N':
                if (b[currentPosition -16] == ' '){ //se la posizione sopra la posizione attuale è parte del campo
                    b[currentPosition] = '.';
                    b[currentPosition - 16] = 'o';
                    currentPosition = currentPosition - 16; //nuova pos. attuale
                    printLabirint(&board[0][0], 16, 16);
                }
                break;

            case 'S':
                if (b[currentPosition +16] == ' '){ //se la posizione sotto la posizione attuale è parte del campo
                    b[currentPosition] = '.';
                    b[currentPosition + 16] = 'o';
                    currentPosition = currentPosition + 16; //nuova pos. attuale
                    printLabirint(&board[0][0], 16, 16);
                }
                break;

            case 'E':
                if (b[currentPosition +1] == ' '){ //se la posizione a destra della posizione attuale è parte del campo
                    b[currentPosition] = '.'; 
                    b[currentPosition + 1] = 'o';
                    currentPosition = currentPosition + 1; //nuova pos. attuale
                    printLabirint(&board[0][0], 16, 16);
                }
                break;

            case 'O':
                if (b[currentPosition - 1] == ' '){ //se la posizione a sinistra della posizione attuale è parte del campo
                    b[currentPosition] = '.';
                    b[currentPosition - 1] = 'o';
                    currentPosition = currentPosition - 1; //nuova pos. attuale
                    printLabirint(&board[0][0], 16, 16);
                }
                break;

        }
    }while(!flag);

}




int main(){


    voidBoard(&board[0][0], 16, 16);
    Labirint(&board[0][0], 16,16);
    start(&board[0][0], 16, 16);
    printLabirint(&board[0][0], 16, 16);
    Moving(&board[0][0], 16, 16);
    printLabirint(&board[0][0], 16, 16);

    return 0;
}
